package other_problem;


/**
 * Bloom Filter 布隆过滤器：
 *      1、一个很长的二进制向量和一个映射函数。
 *      2、用于检索一个元素是否在一个集合中。
 *      3、优点是空间和查询时间效率越超一般算法，缺点是有一定的误识别率（仅当存在时）和删除困难，
 *      所以仅仅是一个预先处理模块。
 *
 * 位运算操作：
 *      1、X & 1 == 1 OR == 0 判断奇偶（X % 2 == 1）
 *      2、X = X & (X-1) => 清零最低位的1
 *      3、X & -X => 得到最低位的1。
 *      0s 表示一串 0，1s 表示一串 1。
 *
 * ```
 * x ^ 0s = x      x & 0s = 0      x | 0s = x
 * x ^ 1s = ~x     x & 1s = x      x | 1s = 1s
 * x ^ x = 0       x & x = x       x | x = x
 * ```
 *
 * 利用 x ^ 1s = \~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。
 *
 * ```
 * 1^1^2 = 2
 * ```
 *
 * 利用 x & 0s = 0 和 x & 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。
 *
 * ```
 * 01011011 &
 * 00111100
 * --------
 * 00011000
 * ```
 *
 * 利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。
 *
 * ```
 * 01011011 |
 * 00111100
 * --------
 * 01111111
 * ```
 *
 * **位与运算技巧**
 *
 * n&(n-1) 去除 n 的位级表示中最低的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。
 *
 * ```
 * 01011011 &
 * 01011010
 * --------
 * 01011010
 * ```
 *
 * n&(-n) 得到 n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n=\~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。
 *
 * ```
 * 10110100 &
 * 01001100
 * --------
 * 00000100
 * ```
 *
 * n-(n&(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&(n-1) 效果一样。
 *
 * **移位运算**
 *
 * \>\> n 为算术右移，相当于除以 2n，例如 -7 \>\> 2 = -2。
 *
 * ```
 * 11111111111111111111111111111001  >> 2
 * --------
 * 11111111111111111111111111111110
 * ```
 *
 * \>\>\> n 为无符号右移，左边会补上 0。例如 -7 \>\>\> 2 = 1073741822。
 *
 * ```
 * 11111111111111111111111111111001  >>> 2
 * --------
 * 00111111111111111111111111111111
 * ```
 *
 * << n 为算术左移，相当于乘以 2n。-7 << 2 = -28。
 *
 * ```
 * 11111111111111111111111111111001  << 2
 * --------
 * 11111111111111111111111111100100
 * ```
 *
 * **mask 计算**
 *
 * 要获取 111111111，将 0 取反即可，\~0。
 *
 * 要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1<<(i-1) 。例如 1<<4 得到只有第 5 位为 1 的 mask ：00010000。
 *
 * 要得到 1 到 i 位为 1 的 mask，(1<<i)-1 即可，例如将 (1<<4)-1 = 00010000-1 = 00001111。
 *
 * 要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 \~((1<<i)-1)。
 *
 * **Java 中的位操作**
 *
 * ```html
 * static int Integer.bitCount();           // 统计 1 的数量
 * static int Integer.highestOneBit();      // 获得最高位
 * static String toBinaryString(int i);     // 转换为二进制表示的字符串
 * ```
 *
 * 面试答题四件套：
 *      1、询问：题目细节、边界条件、可能的极端错误情况。
 *      2、可能的解决方案：1）、时间 & 空间。2）、最优解。
 *      3、编码。
 *      4、测试用例。
 *
 * JsonChao的其它核心题库：11题
 */
public class Main {

    public static void main(String[] args) {

    }
}
